#!/usr/bin/python
# -*- coding: utf-8 -*-

import re, struct
from string import strip

# regular expressions
class EmptyObject:
    pass

search = EmptyObject()
search.addr1 = re.compile(r".*0x([0-9A-Fa-f]+)_([0-9A-Fa-f]{4}).*$").search
search.addr2 = re.compile(r"([0-9A-Fa-f]{1,8}) <.*$").search

class AVR():
    def __init__(self, memblocks=None, mem_change_callback=None, bigendian=False):
        """
        Create an instance of the AVR assembler simulator
        @param  memblocks  list of memory blocks in the form: [ { 'mem': bytearray(), 'addr': 0xXXX }, ...]
                           where 'mem' contains the memory bytes and 'addr' the initial address
        @param  mem_change_callback  memory change callback function
        """
        self.PC = 0             # PC corresponds to the index in the self.list
        self.list = []          # asm listing
        self.cycles = 0
        self.addr_to_idx = {}
        self.labels = {}        # dictionary label => index in self.list
        self.curlabel = ""      # current label
        self.mem = bytearray()
        self.mempos = 0x1000
        self.memblocks = memblocks
        self.mem_change_callback = mem_change_callback
        self.ret_addr = 0
        self.rehi = re.compile(r"hi8\((.*)\)").search
        self.relo = re.compile(r"lo8\((.*)\)").search
        self.rehipm = re.compile(r"hi8\(pm\((.*)\)\)").search
        self.relopm = re.compile(r"lo8\(pm\((.*)\)\)").search
        # AVR registers
        self.r = {
                   'r0': 0, 'r1': 0, 'r2': 0, 'r3': 0, 'r4': 0, 'r5': 0, 'r6': 0, 'r7': 0,
                   'r8': 0, 'r9': 0, 'r10': 0, 'r11': 0, 'r12': 0, 'r13': 0, 'r14': 0, 'r15': 0,
                   'r16': 0, 'r17': 0, 'r18': 0, 'r19': 0, 'r20': 0, 'r21': 0, 'r22': 0, 'r23': 0,
                   'r24': 0, 'r25': 0, 'r26': 0, 'r27': 0, 'r28': 0, 'r29': 0, 'r30': 0, 'r31': 0,
                 }
        # flags (Status Register SREG)
        self.f = {
                   '_EQ': False,      # Internal - True if the comparison was equal
                   '_SH': False,      # Internal - True if the comparison was same or higher
                   '_LO': False,      # Internal - True if the comparison was lower
                   'Z': False,        # zero flag
                   'N': False,        # negative flag
                   'C': False,        # carry flag
                   'V': False,        # overflow flag
                   'S': False,        # N âŠ• V, for signed tests
                   'H': False,        # Half Carry flag in the status register
                   'T': False,        # Transfer bit used by BLD and BST instructions I: Global interrupt enable/disable flag
                 }
        # endian style
        self.bigendian = bigendian
        if self.bigendian:
            self.endian_offset = (3, 2, 1, 0)
        else:
            self.endian_offset = (0, 1, 2, 3)

    def reset(self):
        self.cycles = 0
        for key in self.r.keys():
            self.r[key] = 0
        for key in self.f.keys():
            self.f[key] = False

    def set_memory(self, memblocks):
        self.memblocks = memblocks

    def get_value(self, oper):
        # X,Y,Z: Indirect address register (X=R27:R26, Y=R29:R28 and Z=R31:R30)
        operlow = oper.lower()
        if operlow == "xl":
            oper = "r26"
        elif operlow == "xh":
            oper = "r27"
        elif operlow == "yl":
            oper = "r28"
        elif operlow == "yh":
            oper = "r29"
        elif operlow == "zl":
            oper = "r30"
        elif operlow == "zh":
            oper = "r31"
        else:
            # hi8 and lo8 with pm macros
            match = self.rehipm(oper)
            if match:
                if not self.labels.get(match.group(1)):
                    print "Unknown label %s"%match.group(1)
                    return
                return (self.labels[match.group(1)]['mempos'] >> 8) & 0xFF
            match = self.relopm(oper)
            if match:
                if not self.labels.get(match.group(1)):
                    print "Unknown label %s"%match.group(1)
                    return
                return self.labels[match.group(1)]['mempos'] & 0xFF
            # hi8 and lo8 macros
            match = self.rehi(oper)
            if match:
                if not self.labels.get(match.group(1)):
                    print "Unknown label %s"%match.group(1)
                    return
                return (self.labels[match.group(1)]['mempos'] >> 8) & 0xFF
            match = self.relo(oper)
            if match:
                if not self.labels.get(match.group(1)):
                    print "Unknown label %s"%match.group(1)
                    return
                return self.labels[match.group(1)]['mempos'] & 0xFF
        if oper[0] == 'r' or oper in self.r.keys():
            value = self.r.get(oper) or 0
        else:
            try:
                value = int(oper, 0)
            except:
                print "Error getting value of: %s"%oper
                value = 0
        return value

    def set_value(self, r, value):
        operlow = r.lower()
        if operlow == "xl":
            r = "r26"
        elif operlow == "xh":
            r = "r27"
        elif operlow == "yl":
            r = "r28"
        elif operlow == "yh":
            r = "r29"
        elif operlow == "zl":
            r = "r30"
        elif operlow == "zh":
            r = "r31"
        #if self.r.get(r) is None:
        #    print "Unknown register: %s"%(r)
        #    return
        self.r[r] = value

    def parse_asm_line(self, line, cnt):
        """
            appends a dictionary representing the assembler parsed line in self.list, e.g.
            [
                {
                  'line': 10,               # corresponding line number in the .S file or -1
                  'inst': 'cbi',            # the instruction
                  'oper': [ 'PORTA', '1' ]  # operands list
                },
                ...
            ]
        """
        # discard comments
        l = line.strip().split(";")[0].strip()
        if l == "":
            return
        l = l.split()
        if len(l) < 1:
            return
        # ignore some pre-compiler stuff for now
        if l[0].startswith("#") or l[0] in (".global", ".org" ):
            return
        if l[0].endswith(":"):
            # this is a label
            self.curlabel = l[0][:-1]
            self.labels[self.curlabel] = { 'line': len(self.list), 'mempos': self.mempos }
        else:
            oper = " ".join(l[1:]).lower().split(",")
            if l[0] == ".byte":
                for c in oper:
                    self.mem.append("%c"%int(c, 0))
                    self.mempos += 1
            else:
                self.addr_to_idx[self.mempos] = len(self.list)
                self.list.append({ 'line': cnt, 'inst': l[0].lower(), 'oper': map(strip, oper), 'mempos': self.mempos })
                self.mem.append("%c"%0)
                self.mempos += 1

    def execute_asm_line(self, idx):
        """
        Process a line of assembler code.
        @param  idx  the index in list to be executed
        @return a tuple with the following format:
            (
                err,                        # error description or None on success
                next_addr,                  # next address to be executed, -1 to execute next or None to stay in current instruction (on error)
            )
        """
        list = self.list
        line = list[idx]
        next_addr = -1
        # get instructions
        inst_len = len(line['inst'])
        if inst_len < 1:
            return ("Invalid instruction", None)
        inst = line['inst']
        oper = line['oper']
        oper_len = len(oper)

        """
        Arithmetic and Logic Instructions
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |MNEMONIC      |OPERANDS    |DESCRIPTION                                                      |OPERATION                           |FLAGS             |CYCLES  |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |ADD           |<Rd>,<Rr>   |Add without Carry                                                |Rd = Rd + Rr                        |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |ADC           |<Rd>,<Rr>   |Add with Carry                                                   |Rd = Rd + Rr + C                    |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SUB           |<Rd>,<Rr>   |Subtract without Carry                                           |Rd = Rd - Rr                        |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SUBI          |<Rd>,<K8>   |Subtract Immediate                                               |Rd = Rd - K8                        |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SBC           |<Rd>,<Rr>   |Subtract with Carry                                              |Rd = Rd - Rr - C                    |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SBCI          |<Rd>,<K8>   |Subtract with Carry Immedtiate                                   |Rd = Rd - K8 - C                    |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |AND           |<Rd>,<Rr>   |Logical AND                                                      |Rd = Rd MIDDOT Rr                   |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |ANDI          |<Rd>,<K8>   |Logical AND with Immediate                                       |Rd = Rd MIDDOT K8                   |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |OR            |<Rd>,<Rr>   |Logical OR                                                       |Rd = Rd V Rr                        |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |ORI           |<Rd>,<K8>   |Logical OR with Immediate                                        |Rd = Rd V K8                        |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |EOR           |<Rd>,<Rr>   |Logical Exclusive OR                                             |Rd = Rd EOR Rr                      |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |COM           |<Rd>        |One's Complement                                                 |Rd = $FF - Rd                       |Z,C,N,V,S         |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |NEG           |<Rd>        |Two's Complement                                                 |Rd = $00 - Rd                       |Z,C,N,V,H,S       |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SBR           |<Rd>,<K8>   |Set Bit(s) in Register                                           |Rd = Rd V K8                        |Z,C,N,V,S         |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |CBR           |<Rd>,<K8>   |Clear Bit(s) in Register                                         |Rd = Rd MIDDOT ($FF - K8)           |Z,C,N,V,S         |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        +INC           |<Rd>        |Increment Register                                               |Rd = Rd + 1                         |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        +DEC           |<Rd>        |Decrement Register                                               |Rd = Rd -1                          |Z,N,V,S           |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |TST           |<Rd>        |Test for Zero or Negative                                        |Rd = Rd MIDDOT Rd                   |Z,C,N,V,S         |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |CLR           |<Rd>        |Clear Register                                                   |Rd = 0                              |Z,C,N,V,S         |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SER           |<Rd>        |Set Register                                                     |Rd = $FF                            |None              |1       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |ADIW          |<Rdl>,<K6>  |Add Immediate to Word                                            |Rdh:Rdl = Rdh:Rdl + K6              |Z,C,N,V,S         |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |SBIW          |<Rdl>,<K6>  |Subtract Immediate from Word                                     |Rdh:Rdl = Rdh:Rdl - K 6             |Z,C,N,V,S         |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |MUL           |<Rd>,<Rr>   |Multiply Unsigned                                                |R1:R0 = Rd * Rr                     |Z,C               |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |MULS          |<Rd>,<Rr>   |Multiply Signed                                                  |R1:R0 = Rd * Rr                     |Z,C               |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |MULSU         |<Rd>,<Rr>   |Multiply Signed with Unsigned                                    |R1:R0 = Rd * Rr                     |Z,C               |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |FMUL          |<Rd>,<Rr>   |Fractional Multiply Unsigned                                     |R1:R0 = (Rd * Rr) << 1              |Z,C               |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |FMULS         |<Rd>,<Rr>   |Fractional Multiply Signed                                       |R1:R0 = (Rd *Rr) << 1               |Z,C               |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        |FMULSU        |<Rd>,<Rr>   |Fractional Multiply Signed with Unsigned                         |R1:R0 = (Rd * Rr) << 1              |Z,C               |2       |
         -------------- ------------ ----------------------------------------------------------------- ------------------------------------ ------------------ -------- 
        """
        
        
        """
        Branch Instructions
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |MNEMONIC |OPERANDS |DESCRIPTION                                           |OPERATION                                                   |FLAGS         |CYCLES |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        +RJMP     |<k>      |Relative Jump                                         |PC = PC + k +1                                              |None          |2      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |IJMP     |None     |Indirect Jump to (<Z>)                                |PC = Z                                                      |None          |2      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |EIJMP    |None     |Extended Indirect Jump (<Z>)                          |STACK = PC+1, PC(15:0) = Z, PC(21:16) = EIND                |None          |2      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |JMP      |<k>      |Jump                                                  |PC = k                                                      |None          |3      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |RCALL    |<k>      |Relative Call Subroutine                              |STACK = PC+1, PC = PC + k + 1                               |None          |3/4*   |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |ICALL    |None     |Indirect Call to (<Z>)                                |STACK = PC+1, PC = Z                                        |None          |3/4*   |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |EICALL   |None     |Extended Indirect Call to (<Z>)                       |STACK = PC+1, PC(15:0) = Z, PC(21:16) =EIND                 |None          |4*     |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |CALL     |<k>      |Call Subroutine                                       |STACK = PC+2, PC = k                                        |None          |4/5*   |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |RET      |None     |Subroutine Return                                     |PC = STACK                                                  |None          |4/5*   |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |RETI     |None     |Interrupt Return                                      |PC = STACK                                                  |I             |4/5*   |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |CPSE     |<Rd>,<Rr>|Compare, Skip if equal                                |if (Rd ==Rr) PC = PC 2 or 3                                 |None          |1/2/3  |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |CP       |<Rd>,<Rr>|Compare                                               |Rd -Rr                                                      |Z,C,N,V,H,S   |1      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |CPC      |<Rd>,<Rr>|Compare with Carry                                    |Rd - Rr - C                                                 |Z,C,N,V,H,S   |1      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        +CPI      |<Rd>,<K8>|Compare with Immediate                                |Rd - K                                                      |Z,C,N,V,H,S   |1      |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |SBRC     |<Rr>,<b> |Skip if bit in register cleared                       |if(Rr(b)==0) PC = PC + 2 or 3                               |None          |1/2/3  |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |SBRS     |<Rr>,<b> |Skip if bit in register set                           |if(Rr(b)==1) PC = PC + 2 or 3                               |None          |1/2/3  |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |SBIC     |<P>,<b>  |Skip if bit in I/O register cleared                   |if(I/O(P,b)==0) PC = PC + 2 or 3                            |None          |1/2/3  |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |SBIS     |<P>,<b>  |Skip if bit in I/O register set                       |if(I/O(P,b)==1) PC = PC + 2 or 3                            |None          |1/2/3  |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRBC     |<s>,<k>  |Branch if Status flag cleared                         |if(SREG(s)==0) PC = PC + k + 1                              |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRBS     |<s>,<k>  |Branch if Status flag set                             |if(SREG(s)==1) PC = PC + k + 1                              |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        +BREQ     |<k>      |Branch if equal                                       |if(Z==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        +BRNE     |<k>      |Branch if not equal                                   |if(Z==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRCS     |<k>      |Branch if carry set                                   |if(C==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRCC     |<k>      |Branch if carry cleared                               |if(C==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRSH     |<k>      |Branch if same or higher                              |if(C==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRLO     |<k>      |Branch if lower                                       |if(C==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRMI     |<k>      |Branch if minus                                       |if(N==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRPL     |<k>      |Branch if plus                                        |if(N==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRGE     |<k>      |Branch if greater than or equal (signed)              |if(S==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRLT     |<k>      |Branch if less than (signed)                          |if(S==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRHS     |<k>      |Branch if half carry flag set                         |if(H==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRHC     |<k>      |Branch if half carry flag cleared                     |if(H==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRTS     |<k>      |Branch if T flag set                                  |if(T==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRTC     |<k>      |Branch if T flag cleared                              |if(T==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRVS     |<k>      |Branch if overflow flag set                           |if(V==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRVC     |<k>      |Branch if overflow flag cleared                       |if(V==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRIE     |<k>      |Branch if interrupt enabled                           |if(I==1) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        |BRID     |<k>      |Branch if interrupt disabled                          |if(I==0) PC = PC + k + 1                                    |None          |1/2    |
         --------- --------- ------------------------------------------------------ ------------------------------------------------------------ -------------- ------- 
        """
        
        """
        Data Transfer Instructions
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |MNEMONIC    |OPERANDS   |DESCRIPTION                                                               |OPERATION                                 |FLAGS |CYCLES  |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |MOV         |<Rd>,<Rr>  |Copy register                                                             |Rd = Rr                                   |None  |1       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |MOVW        |<Rd>,<Rr>  |Copy register pair                                                        |Rd+1:Rd = Rr+1:Rr, r,d even               |None  |1       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        +LDI         |<Rd>,<K8>  |Load Immediate                                                            |Rd = K                                    |None  |1       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LDS         |<Rd>,<k>   |Load Direct                                                               |Rd = (k)                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<X>   |Load Indirect                                                             |Rd = (X)                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<X+>  |Load Indirect and Post-Increment                                          |Rd = (X), X=X+1                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<-X>  |Load Indirect and Pre-Decrement                                           |X=X-1, Rd = (X)                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<Y>   |Load Indirect                                                             |Rd = (Y)                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<Y+>  |Load Indirect and Post-Increment                                          |Rd = (Y), Y=Y+1                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<-Y>  |Load Indirect and Pre-Decrement                                           |Y=Y-1, Rd = (Y)                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LDD         |<Rd>,<Y>+<q|Load Indirect with displacement                                           |Rd = (Y+q)                                |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<Z>   |Load Indirect                                                             |Rd = (Z)                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<Z+>  |Load Indirect and Post-Increment                                          |Rd = (Z), Z=Z+1                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LD          |<Rd>,<-Z>  |Load Indirect and Pre-Decrement                                           |Z=Z-1, Rd = (Z)                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LDD         |<Rd>,<Z>+<q|Load Indirect with displacement                                           |Rd = (Z+q)                                |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |STS         |k,<Rr>     |Store Direct                                                              |(k) = Rr                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<X>,<Rr>   |Store Indirect                                                            |(X) = Rr                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<X+>,<Rr>  |Store Indirect and Post-Increment                                         |(X) = Rr, X=X+1                           |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<-X>,<Rr>  |Store Indirect and Pre-Decrement                                          |X=X-1, (X)=Rr                             |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<Y>,<Rr>   |Store Indirect                                                            |(Y) = Rr                                  |None  |2*      |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<Y+>,<Rr>  |Store Indirect and Post-Increment                                         |(Y) = Rr, Y=Y+1                           |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<-Y>,<Rr>  |Store Indirect and Pre-Decrement                                          |Y=Y-1, (Y) = Rr                           |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<Y>+<q>,<Rr|Store Indirect with displacement                                          |(Y+q) = Rr                                |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<Z>,<Rr>   |Store Indirect                                                            |(Z) = Rr                                  |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<Z+>,<Rr>  |Store Indirect and Post-Increment                                         |(Z) = Rr, Z=Z+1                           |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<-Z>,<Rr>  |Store Indirect and Pre-Decrement                                          |Z=Z-1, (Z) = Rr                           |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ST          |<Z>+<q>,<Rr|Store Indirect with displacement                                          |(Z+q) = Rr                                |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LPM         |None       |Load Program Memory                                                       |R0 = (<Z>)                                |None  |3       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LPM         |<Rd>,<Z>   |Load Program Memory                                                       |Rd = (<Z>)                                |None  |3       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |LPM         |<Rd>,<Z+>  |Load Program Memory and Post-Increment                                    |Rd = (<Z>), Z=Z+1                         |None  |3       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ELPM        |None       |Extended Load Program Memory                                              |R0 = (RAMPZ:<Z>)                          |None  |3       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ELPM        |<Rd>,<Z>   |Extended Load Program Memory                                              |Rd = (RAMPZ:<Z>)                          |None  |3       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ELPM        |<Rd>,<Z+>  |Extended Load Program Memory and Post Increment                           |Rd = (RAMPZ:<Z>), Z = Z+1                 |None  |3       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |SPM         |None       |Store Program Memory                                                      |(<Z>) = R1:R0                             |None  |-       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |ESPM        |None       |Extended Store Program Memory                                             |(RAMPZ:<Z>) = R1:R0                       |None  |-       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |IN          |<Rd>,<P>   |In Port                                                                   |Rd = P                                    |None  |1       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |OUT         |<P>,<Rr>   |Out Port                                                                  |P = Rr                                    |None  |1       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |PUSH        |<Rr>       |Push register on Stack                                                    |STACK = Rr                                |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        |POP         |<Rd>       |Pop register from Stack                                                   |Rd = STACK                                |None  |2       |
         ------------ ----------- -------------------------------------------------------------------------- ------------------------------------------ ------ -------- 
        """
        
        """
        Bit and Bit-test Instructions
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |MNEMONIC    |OPERANDS   |DESCRIPTION                                |OPERATION                                                      |FLAGS           |CYCLES  |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |LSL         |<Rd>       |Logical shift left                         |Rd(n+1)=Rd(n), Rd(0)=0, C=Rd(7)                                |Z,C,N,V,H,S     |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |LSR         |<Rd>       |Logical shift right                        |Rd(n)=Rd(n+1), Rd(7)=0, C=Rd(0)                                |Z,C,N,V,S       |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |ROL         |<Rd>       |Rotate left through carry                  |Rd(0)=C, Rd(n+1)=Rd(n), C=Rd(7)                                |Z,C,N,V,H,S     |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |ROR         |<Rd>       |Rotate right through carry                 |Rd(7)=C, Rd(n)=Rd(n+1), C=Rd(0)                                |Z,C,N,V,S       |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |ASR         |<Rd>       |Arithmetic shift right                     |Rd(n)=Rd(n+1), n=0,...,6                                       |Z,C,N,V,S       |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SWAP        |<Rd>       |Swap nibbles                               |Rd(3..0) = Rd(7..4), Rd(7..4) = Rd(3..0)                       |None            |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |BSET        |<s>        |Set flag                                   |SREG(s) = 1                                                    |SREG(s)         |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |BCLR        |<s>        |Clear flag                                 |SREG(s) = 0                                                    |SREG(s)         |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        +SBI         |<P>,<b>    |Set bit in I/O register                    |I/O(P,b) = 1                                                   |None            |2       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        +CBI         |<P>,<b>    |Clear bit in I/O register                  |I/O(P,b) = 0                                                   |None            |2       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |BST         |<Rr>,<b>   |Bit store from register to T               |T = Rr(b)                                                      |T               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |BLD         |<Rd>,<b>   |Bit load from register to T                |Rd(b) = T                                                      |None            |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SEC         |None       |Set carry flag                             |C =1                                                           |C               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLC         |None       |Clear carry flag                           |C = 0                                                          |C               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SEN         |None       |Set negative flag                          |N = 1                                                          |N               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLN         |None       |Clear negative flag                        |N = 0                                                          |N               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SEZ         |None       |Set zero flag                              |Z = 1                                                          |Z               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLZ         |None       |Clear zero flag                            |Z = 0                                                          |Z               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SEI         |None       |Set interrupt flag                         |I = 1                                                          |I               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLI         |None       |Clear interrupt flag                       |I = 0                                                          |I               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SES         |None       |Set signed flag                            |S = 1                                                          |S               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLN         |None       |Clear signed flag                          |S = 0                                                          |S               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SEV         |None       |Set overflow flag                          |V = 1                                                          |V               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLV         |None       |Clear overflow flag                        |V = 0                                                          |V               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SET         |None       |Set T-flag                                 |T = 1                                                          |T               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLT         |None       |Clear T-flag                               |T = 0                                                          |T               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SEH         |None       |Set half carry flag                        |H = 1                                                          |H               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |CLH         |None       |Clear half carry flag                      |H = 0                                                          |H               |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        +NOP         |None       |No operation                               |None                                                           |None            |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |SLEEP       |None       |Sleep                                      |See instruction manual                                         |None            |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        |WDR         |None       |Watchdog Reset                             |See instruction manual                                         |None            |1       |
         ------------ ----------- ------------------------------------------- --------------------------------------------------------------- ---------------- -------- 
        """
        if inst == "nop":
            self.cycles += 1
        elif inst in ("ldi", "mov"):         # Load Immediate
            self.set_value(oper[0], self.get_value(oper[1]))
            self.cycles += 1
        elif inst == "lpm":          # Load program memory
            mempos = (self.r['r31'] << 8) | self.r['r30']
            if mempos < 0x1000:
                return ("Invalid address for '%s': 0x%.4x"%(oper[0], mempos), None)
            mempos = mempos - 0x1000
            self.set_value("r0", self.mem[mempos] & 0xFF)
            self.cycles += 3
        elif inst == "ld":          # Load Indirect from SRAM to Register using Index [X, Y, X]
            mempos = 0
            operlow = oper[1].lower()
            if operlow == "x":
                mempos = (self.r['r27'] << 8) | self.r['r26']
            elif operlow == "y":
                mempos = (self.r['r29'] << 8) | self.r['r28']
            elif operlow == "z":
                mempos = (self.r['r31'] << 8) | self.r['r30']
            if mempos < 0x1000:
                return ("Invalid address for '%s': 0x%.4x"%(oper[1], mempos), None)
            mempos = mempos - 0x1000
            self.set_value(oper[0], self.mem[mempos] & 0xFF)
            self.cycles += 2
        elif inst in ("add", "adc"):         # Add
            a, b = (self.get_value(oper[0]), self.get_value(oper[1]))
            c = a + b
            if inst == "adc":
                c += 1 if self.f['C'] else 0
            self.set_value(oper[0], c & 0xFF)
            self.f['N'] = c < 0
            self.f['Z'] = c == 0
            self.f['C'] = c > 0xFF
            self.cycles += 1
        elif inst in ("cpi", "subi"):         # Compare with Immediate
            a, b = (self.get_value(oper[0]), self.get_value(oper[1]))
            c = a - b
            if inst == "subi":
                self.set_value(oper[0], c)
            self.f['_EQ'] = a == b
            self.f['_LO'] = a < b
            self.f['_SH'] = a >= b
            self.f['N'] = c < 0
            self.f['Z'] = c == 0
            self.f['C'] = abs(b) > abs(a)
            self.cycles += 1
        elif inst in ("com"):
            self.set_value(oper[0], abs(~self.get_value(oper[0])))
            self.cycles += 1
        elif inst == "breq":        # Branch if equal
            if self.f['_EQ']:
                next_addr = self.labels[oper[0]]['line']
                self.cycles += 2
            else:
                self.cycles += 1
        elif inst == "brne":        # Branch if not equal
            if not self.f['_EQ']:
                next_addr = self.labels[oper[0]]['line']
                self.cycles += 2
            else:
                self.cycles += 1
        elif inst == "brlo":        # Branch if lower
            if self.f['_LO']:
                next_addr = self.labels[oper[0]]['line']
                self.cycles += 2
            else:
                self.cycles += 1
        elif inst == "brsh":        # Branch if same or higher
            if self.f['_SH']:
                next_addr = self.labels[oper[0]]['line']
                self.cycles += 2
            else:
                self.cycles += 1
        elif inst == "brcc":        # Branch if Carry Cleared
            if not self.f['C']:
                next_addr = self.labels[oper[0]]['line']
                self.cycles += 2
            else:
                self.cycles += 1
        elif inst == "rjmp":        # Relative jump
            next_addr = self.labels[oper[0]]['line']
            self.cycles += 2
        elif inst == "rcall":        # Relative call
            self.ret_addr = idx + 1
            next_addr = self.labels[oper[0]]['line']
            self.cycles += 3
        elif inst == "ret":        # Return
            next_addr = self.ret_addr
            self.cycles += 4
        elif inst == "ijmp":        # Relative jump
            zaddr = (self.r['r31'] << 8) | self.r['r30']
            next_addr = self.addr_to_idx[zaddr]
            self.cycles += 2
        elif inst == "sbi":         # Set Bit in I/O Register
            self.set_value(oper[0], self.get_value(oper[0]) | (1 << self.get_value(oper[1])))
            self.cycles += 2
        elif inst == "cbi":         # Clear Bit in I/O Register
            self.set_value(oper[0], self.get_value(oper[0]) & ~(1 << self.get_value(oper[1])))
            self.cycles += 2
        elif inst == "inc":         # Increment
            a = self.get_value(oper[0]) + 1
            if a > 0xFF: a = 0
            self.set_value(oper[0], a)
            self.f['_EQ'] = a == 0
            self.f['Z'] = a == 0
            self.cycles += 1
        elif inst == "dec":         # Decrement
            a = self.get_value(oper[0]) - 1
            if a < 0: a = 0xFF
            self.set_value(oper[0], a)
            self.f['_EQ'] = a == 0
            self.f['Z'] = a == 0
            self.cycles += 1
        elif inst == "ror":         # ROR
            carry = self.get_value(oper[0]) & 1
            c = self.get_value(oper[0]) >> 1
            if self.f['C']:
                c = c & 0x80
            self.set_value(oper[0], c)
            self.f['C'] = carry == 1
            self.cycles += 1
        elif inst == "cli":
            self.cycles += 1
        elif inst == "out":
            print "OUT not implemented yet!"
            self.cycles += 2
        else:
            # unknown instruction
            return ("Sorry, I don't know how to process instruction '%s' yet"%inst, None)
        # return normally
        return (None, next_addr)
